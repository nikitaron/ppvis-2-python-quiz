code: |
    class CallMe:
        def __call__(self, *args, **kwargs): 
            print('Called:', args, kwargs)  
    
    C = CallMe()
    C(4, 5, 6,  x=10, y=20)

output: "Called: (4, 5, 6) {'x': 10, 'y': 20}"
tag: 
 - class/method/call

---

code: |
  class Test:
    def __init__(self, value):
        self.value = value

  X = Test(2)
  print(X(3))

output: "TypeError: 'Test' object is not callable"
tag: 
 - class/variable 

---

code: |

 class A:
    pass

 print(A.__class__)

output: "<class 'type'>"
tag: 
 - class/method/class
---

code: |
    from math import ceil
    
    class Number:
        def __init__(self, number):
            self.number = number
    
        def __ceil__(self):
            self.number = ceil(self.number)
    
    number = Number(1.1)
    print(ceil(number)) 

output: "None"
tag: 
 - class/method/ceil

---

class Moon:
    r = 1737.10

    def __ge__(self, other):
        print('moon ge')
        return self.r >= other

my_moon = Moon()

is_ge = (my_moon => 6371.0) 

output: "SyntaxError: invalid syntax"
tag: 
 - class/method/ge

---

code: |
    class Test:
    r = 10

    def __mod__(self, other):
        return self.r % other

    test = Test()

    test2 = (test % 3)

    print(test2) 

output: "1"
tag: 
 - class/method/mod

---

code: |

   class A:
       def __init__(self):
           self.a = 0

       def change(self, n):
           a = n
        
   obj = A()
   obj.change(2)
   print(obj.a)

output: "0"
tag: 
 - class/
---

code: |
    class Number:
        def __init__(self, number):
            self.number = number
    
        def __iadd__(self, other):
            self.number += other
            return self.number
    
    number = Number(10.3)
    number += 20
    print(number)

output: "30.3"
tag: 
 - class/method/iadd

---

code: |
    class MyDict(dict):
    
        def __missing__(self, key):
            return -1
    
    my_dict = MyDict()
    my_dict[0] = 1
    
    print(my_dict[1])

output: "-1"
tag: 
 - class/method/missing

---

code: |
    class Test:
    
        def __init__(self, number):
            self.number = number
    
        def __divmod__(self, other):
            return self.number % other
    
    a = Test(10)
    b = Test(3)
    print(divmod(a, b))

output: "TypeError: unsupported operand type(s) for %: 'int' and 'Test'"
tag: 
 - class/method/divmod

---

code: |
    class MyContainer:
    
        def __init__(self):
            self.items = [1, 2]
    
        def __contains__(self, item):
            return item in self.items
    
    my_container = MyContainer()
    
    print(1 in my_container)

output: "True"
tag: 
 - class/method/contains

---

code: |
    import math
    
    class Number:
        def __init__(self, number):
            self.number = number
    
        def __floor__(self):
            return math.floor(self.number)
    
    number = Number(1.1)
    print(math.floor(number))

output: "1"
tag: 
 - class/method/floor

---

code: |
    class invertClass():
      def __init__(self, value):
         self._value = value

      def __invert__(self):
         return self._value[::-1]

      def __str__(self):
         return self._value

    invrt = invertClass('Hello, George')
    invertedValue = ~invrt

    print(invertedValue)

output: "egroeG ,olleH"
tag: 
 - class/method/invert

---


code: |
  class unaryOp():
    def __init__(self, value):
        self._value = value

    def __pos__(self):
        return (+self._value)

  up = unaryOp(5)
  print(+up)

output: "5"
tag: 
 - class/method/pos
